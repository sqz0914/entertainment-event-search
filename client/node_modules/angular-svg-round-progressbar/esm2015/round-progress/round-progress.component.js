import { Component, Input, Output, NgZone, EventEmitter, ViewChild, Inject, ChangeDetectionStrategy, } from '@angular/core';
import { RoundProgressService } from './round-progress.service';
import { ROUND_PROGRESS_DEFAULTS } from './round-progress.config';
import { RoundProgressEase } from './round-progress.ease';
export class RoundProgressComponent {
    constructor(service, easing, defaults, ngZone) {
        this.service = service;
        this.easing = easing;
        this.defaults = defaults;
        this.ngZone = ngZone;
        this.currentLinecap = '';
        /** Radius of the circle. */
        this.radius = this.defaults.radius;
        /** Name of the easing function to use when animating. */
        this.animation = this.defaults.animation;
        /** Time in millisconds by which to delay the animation. */
        this.animationDelay = this.defaults.animationDelay;
        /** Duration of the animation. */
        this.duration = this.defaults.duration;
        /** Width of the circle's stroke. */
        this.stroke = this.defaults.stroke;
        /** Color of the circle. */
        this.color = this.defaults.color;
        /** Background color of the circle. */
        this.background = this.defaults.background;
        /** Whether the circle should take up the width of its parent. */
        this.responsive = this.defaults.responsive;
        /** Whether the circle is filling up clockwise. */
        this.clockwise = this.defaults.clockwise;
        /** Whether to render a semicircle. */
        this.semicircle = this.defaults.semicircle;
        /** Whether the tip of the progress should be rounded off. */
        this.rounded = this.defaults.rounded;
        /** Emits when a new value has been rendered. */
        this.onRender = new EventEmitter();
        this.lastAnimationId = 0;
    }
    /** Animates a change in the current value. */
    _animateChange(from, to) {
        if (typeof from !== 'number') {
            from = 0;
        }
        to = this._clamp(to);
        from = this._clamp(from);
        const self = this;
        const changeInValue = to - from;
        const duration = self.duration;
        // Avoid firing change detection for each of the animation frames.
        self.ngZone.runOutsideAngular(() => {
            const start = () => {
                const startTime = self.service.getTimestamp();
                const id = ++self.lastAnimationId;
                requestAnimationFrame(function animation() {
                    const currentTime = Math.min(self.service.getTimestamp() - startTime, duration);
                    const value = self.easing[self.animation](currentTime, from, changeInValue, duration);
                    self._updatePath(value);
                    if (self.onRender.observers.length > 0) {
                        self.onRender.emit(value);
                    }
                    if (id === self.lastAnimationId && currentTime < duration) {
                        requestAnimationFrame(animation);
                    }
                });
            };
            if (this.animationDelay > 0) {
                setTimeout(start, this.animationDelay);
            }
            else {
                start();
            }
        });
    }
    /** Updates the path apperance. */
    _updatePath(value) {
        if (this.path) {
            const arc = this.service.getArc(value, this.max, this.radius - this.stroke / 2, this.radius, this.semicircle);
            const path = this.path.nativeElement;
            // Remove the rounded line cap when the value is zero, because SVG won't allow it to disappear completely.
            const linecap = this.rounded && value > 0 ? 'round' : '';
            // This is called on each animation frame so avoid updating the line cap unless it has changed.
            if (linecap !== this.currentLinecap) {
                this.currentLinecap = linecap;
                path.style.strokeLinecap = linecap;
            }
            path.setAttribute('d', arc);
        }
    }
    /** Clamps a value between the maximum and 0. */
    _clamp(value) {
        return Math.max(0, Math.min(value || 0, this.max));
    }
    /** Determines the SVG transforms for the <path> node. */
    getPathTransform() {
        const diameter = this._getDiameter();
        if (this.semicircle) {
            return this.clockwise
                ? `translate(0, ${diameter}) rotate(-90)`
                : `translate(${diameter + ',' + diameter}) rotate(90) scale(-1, 1)`;
        }
        else if (!this.clockwise) {
            return `scale(-1, 1) translate(-${diameter} 0)`;
        }
    }
    /** Resolves a color through the service. */
    resolveColor(color) {
        return this.service.resolveColor(color);
    }
    /** Change detection callback. */
    ngOnChanges(changes) {
        if (changes.current) {
            this._animateChange(changes.current.previousValue, changes.current.currentValue);
        }
        else {
            this._updatePath(this.current);
        }
    }
    /** Diameter of the circle. */
    _getDiameter() {
        return this.radius * 2;
    }
    /** The CSS height of the wrapper element. */
    _getElementHeight() {
        if (!this.responsive) {
            return (this.semicircle ? this.radius : this._getDiameter()) + 'px';
        }
    }
    /** Viewbox for the SVG element. */
    _getViewBox() {
        const diameter = this._getDiameter();
        return `0 0 ${diameter} ${this.semicircle ? this.radius : diameter}`;
    }
    /** Bottom padding for the wrapper element. */
    _getPaddingBottom() {
        if (this.responsive) {
            return this.semicircle ? '50%' : '100%';
        }
    }
}
RoundProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'round-progress',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: "<svg xmlns=\"http://www.w3.org/2000/svg\" [attr.viewBox]=\"_getViewBox()\">\n  <circle\n    fill=\"none\"\n    [attr.cx]=\"radius\"\n    [attr.cy]=\"radius\"\n    [attr.r]=\"radius - stroke / 2\"\n    [style.stroke]=\"resolveColor(background)\"\n    [style.stroke-width]=\"stroke\"/>\n\n  <path\n    #path\n    fill=\"none\"\n    [style.stroke-width]=\"stroke\"\n    [style.stroke]=\"resolveColor(color)\"\n    [attr.transform]=\"getPathTransform()\"/>\n</svg>\n",
                host: {
                    role: 'progressbar',
                    '[attr.aria-valuemin]': '0',
                    '[attr.aria-valuemax]': 'max',
                    '[attr.aria-valuenow]': 'current',
                    '[style.width]': 'responsive ? "" : _getDiameter() + "px"',
                    '[style.height]': '_getElementHeight()',
                    '[style.padding-bottom]': '_getPaddingBottom()',
                    '[class.responsive]': 'responsive',
                },
                styles: [":host{display:block;position:relative;overflow:hidden}:host(.responsive){width:100%;padding-bottom:100%}:host(.responsive)>svg{position:absolute;width:100%;height:100%;top:0;left:0}"]
            },] }
];
RoundProgressComponent.ctorParameters = () => [
    { type: RoundProgressService },
    { type: RoundProgressEase },
    { type: undefined, decorators: [{ type: Inject, args: [ROUND_PROGRESS_DEFAULTS,] }] },
    { type: NgZone }
];
RoundProgressComponent.propDecorators = {
    path: [{ type: ViewChild, args: ['path',] }],
    current: [{ type: Input }],
    max: [{ type: Input }],
    radius: [{ type: Input }],
    animation: [{ type: Input }],
    animationDelay: [{ type: Input }],
    duration: [{ type: Input }],
    stroke: [{ type: Input }],
    color: [{ type: Input }],
    background: [{ type: Input }],
    responsive: [{ type: Input }],
    clockwise: [{ type: Input }],
    semicircle: [{ type: Input }],
    rounded: [{ type: Input }],
    onRender: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91bmQtcHJvZ3Jlc3MuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9yb3VuZC1wcm9ncmVzcy9yb3VuZC1wcm9ncmVzcy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxLQUFLLEVBQ0wsTUFBTSxFQUVOLE1BQU0sRUFDTixZQUFZLEVBQ1osU0FBUyxFQUNULE1BQU0sRUFHTix1QkFBdUIsR0FDeEIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFDLG9CQUFvQixFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFDOUQsT0FBTyxFQUFDLHVCQUF1QixFQUF3QixNQUFNLHlCQUF5QixDQUFDO0FBQ3ZGLE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBa0J4RCxNQUFNLE9BQU8sc0JBQXNCO0lBa0RqQyxZQUNVLE9BQTZCLEVBQzdCLE1BQXlCLEVBQ1EsUUFBK0IsRUFDaEUsTUFBYztRQUhkLFlBQU8sR0FBUCxPQUFPLENBQXNCO1FBQzdCLFdBQU0sR0FBTixNQUFNLENBQW1CO1FBQ1EsYUFBUSxHQUFSLFFBQVEsQ0FBdUI7UUFDaEUsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQXJEaEIsbUJBQWMsR0FBaUIsRUFBRSxDQUFDO1FBVzFDLDRCQUE0QjtRQUNuQixXQUFNLEdBQVcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7UUFFL0MseURBQXlEO1FBQ2hELGNBQVMsR0FBVyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQztRQUVyRCwyREFBMkQ7UUFDbEQsbUJBQWMsR0FBVyxJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQztRQUUvRCxpQ0FBaUM7UUFDeEIsYUFBUSxHQUFXLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDO1FBRW5ELG9DQUFvQztRQUMzQixXQUFNLEdBQVcsSUFBSSxDQUFD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WUFDbkIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztTQUN6QztJQUNILENBQUM7OztZQTlMRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGdCQUFnQjtnQkFDMUIsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07Z0JBQy9DLDBkQUE4QztnQkFFOUMsSUFBSSxFQUFFO29CQUNKLElBQUksRUFBRSxhQUFhO29CQUNuQixzQkFBc0IsRUFBRSxHQUFHO29CQUMzQixzQkFBc0IsRUFBRSxLQUFLO29CQUM3QixzQkFBc0IsRUFBRSxTQUFTO29CQUNqQyxlQUFlLEVBQUUseUNBQXlDO29CQUMxRCxnQkFBZ0IsRUFBRSxxQkFBcUI7b0JBQ3ZDLHdCQUF3QixFQUFFLHFCQUFxQjtvQkFDL0Msb0JBQW9CLEVBQUUsWUFBWTtpQkFDbkM7O2FBQ0Y7OztZQW5CTyxvQkFBb0I7WUFFcEIsaUJBQWlCOzRDQXVFcEIsTUFBTSxTQUFDLHVCQUF1QjtZQWxGakMsTUFBTTs7O21CQWlDTCxTQUFTLFNBQUMsTUFBTTtzQkFHaEIsS0FBSztrQkFHTCxLQUFLO3FCQUdMLEtBQUs7d0JBR0wsS0FBSzs2QkFHTCxLQUFLO3VCQUdMLEtBQUs7cUJBR0wsS0FBSztvQkFHTCxLQUFLO3lCQUdMLEtBQUs7eUJBR0wsS0FBSzt3QkFHTCxLQUFLO3lCQUdMLEtBQUs7c0JBR0wsS0FBSzt1QkFHTCxNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBPbkNoYW5nZXMsXG4gIE5nWm9uZSxcbiAgRXZlbnRFbWl0dGVyLFxuICBWaWV3Q2hpbGQsXG4gIEluamVjdCxcbiAgRWxlbWVudFJlZixcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQge1JvdW5kUHJvZ3Jlc3NTZXJ2aWNlfSBmcm9tICcuL3JvdW5kLXByb2dyZXNzLnNlcnZpY2UnO1xuaW1wb3J0IHtST1VORF9QUk9HUkVTU19ERUZBVUxUUywgUm91bmRQcm9ncmVzc0RlZmF1bHRzfSBmcm9tICcuL3JvdW5kLXByb2dyZXNzLmNvbmZpZyc7XG5pbXBvcnQge1JvdW5kUHJvZ3Jlc3NFYXNlfSBmcm9tICcuL3JvdW5kLXByb2dyZXNzLmVhc2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdyb3VuZC1wcm9ncmVzcycsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICB0ZW1wbGF0ZVVybDogJy4vcm91bmQtcHJvZ3Jlc3MuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9yb3VuZC1wcm9ncmVzcy5jb21wb25lbnQuY3NzJ10sXG4gIGhvc3Q6IHtcbiAgICByb2xlOiAncHJvZ3Jlc3NiYXInLFxuICAgICdbYXR0ci5hcmlhLXZhbHVlbWluXSc6ICcwJyxcbiAgICAnW2F0dHIuYXJpYS12YWx1ZW1heF0nOiAnbWF4JyxcbiAgICAnW2F0dHIuYXJpYS12YWx1ZW5vd10nOiAnY3VycmVudCcsXG4gICAgJ1tzdHlsZS53aWR0aF0nOiAncmVzcG9uc2l2ZSA/IFwiXCIgOiBfZ2V0RGlhbWV0ZXIoKSArIFwicHhcIicsXG4gICAgJ1tzdHlsZS5oZWlnaHRdJzogJ19nZXRFbGVtZW50SGVpZ2h0KCknLFxuICAgICdbc3R5bGUucGFkZGluZy1ib3R0b21dJzogJ19nZXRQYWRkaW5nQm90dG9tKCknLFxuICAgICdbY2xhc3MucmVzcG9uc2l2ZV0nOiAncmVzcG9uc2l2ZScsXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgUm91bmRQcm9ncmVzc0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gIHByaXZhdGUgY3VycmVudExpbmVjYXA6ICdyb3VuZCcgfCAnJyA9ICcnO1xuXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgYHBhdGhgIG5vZGUuICovXG4gIEBWaWV3Q2hpbGQoJ3BhdGgnKSBwYXRoOiBFbGVtZW50UmVmPFNWR1BhdGhFbGVtZW50PjtcblxuICAvKiogQ3VycmVudCB2YWx1ZSBvZiB0aGUgcHJvZ3Jlc3MgYmFyLiAqL1xuICBASW5wdXQoKSBjdXJyZW50OiBudW1iZXI7XG5cbiAgLyoqIE1heGltdW0gdmFsdWUgb2YgdGhlIHByb2dyZXNzIGJhci4gKi9cbiAgQElucHV0KCkgbWF4OiBudW1iZXI7XG5cbiAgLyoqIFJhZGl1cyBvZiB0aGUgY2lyY2xlLiAqL1xuICBASW5wdXQoKSByYWRpdXM6IG51bWJlciA9IHRoaXMuZGVmYXVsdHMucmFkaXVzO1xuXG4gIC8qKiBOYW1lIG9mIHRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW4gYW5pbWF0aW5nLiAqL1xuICBASW5wdXQoKSBhbmltYXRpb246IHN0cmluZyA9IHRoaXMuZGVmYXVsdHMuYW5pbWF0aW9uO1xuXG4gIC8qKiBUaW1lIGluIG1pbGxpc2NvbmRzIGJ5IHdoaWNoIHRvIGRlbGF5IHRoZSBhbmltYXRpb24uICovXG4gIEBJbnB1dCgpIGFuaW1hdGlvbkRlbGF5OiBudW1iZXIgPSB0aGlzLmRlZmF1bHRzLmFuaW1hdGlvbkRlbGF5O1xuXG4gIC8qKiBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLiAqL1xuICBASW5wdXQoKSBkdXJhdGlvbjogbnVtYmVyID0gdGhpcy5kZWZhdWx0cy5kdXJhdGlvbjtcblxuICAvKiogV2lkdGggb2YgdGhlIGNpcmNsZSdzIHN0cm9rZS4gKi9cbiAgQElucHV0KCkgc3Ryb2tlOiBudW1iZXIgPSB0aGlzLmRlZmF1bHRzLnN0cm9rZTtcblxuICAvKiogQ29sb3Igb2YgdGhlIGNpcmNsZS4gKi9cbiAgQElucHV0KCkgY29sb3I6IHN0cmluZyA9IHRoaXMuZGVmYXVsdHMuY29sb3I7XG5cbiAgLyoqIEJhY2tncm91bmQgY29sb3Igb2YgdGhlIGNpcmNsZS4gKi9cbiAgQElucHV0KCkgYmFja2dyb3VuZDogc3RyaW5nID0gdGhpcy5kZWZhdWx0cy5iYWNrZ3JvdW5kO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBjaXJjbGUgc2hvdWxkIHRha2UgdXAgdGhlIHdpZHRoIG9mIGl0cyBwYXJlbnQuICovXG4gIEBJbnB1dCgpIHJlc3BvbnNpdmU6IGJvb2xlYW4gPSB0aGlzLmRlZmF1bHRzLnJlc3BvbnNpdmU7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNpcmNsZSBpcyBmaWxsaW5nIHVwIGNsb2Nrd2lzZS4gKi9cbiAgQElucHV0KCkgY2xvY2t3aXNlOiBib29sZWFuID0gdGhpcy5kZWZhdWx0cy5jbG9ja3dpc2U7XG5cbiAgLyoqIFdoZXRoZXIgdG8gcmVuZGVyIGEgc2VtaWNpcmNsZS4gKi9cbiAgQElucHV0KCkgc2VtaWNpcmNsZTogYm9vbGVhbiA9IHRoaXMuZGVmYXVsdHMuc2VtaWNpcmNsZTtcblxuICAvKiogV2hldGhlciB0aGUgdGlwIG9mIHRoZSBwcm9ncmVzcyBzaG91bGQgYmUgcm91bmRlZCBvZmYuICovXG4gIEBJbnB1dCgpIHJvdW5kZWQ6IGJvb2xlYW4gPSB0aGlzLmRlZmF1bHRzLnJvdW5kZWQ7XG5cbiAgLyoqIEVtaXRzIHdoZW4gYSBuZXcgdmFsdWUgaGFzIGJlZW4gcmVuZGVyZWQuICovXG4gIEBPdXRwdXQoKSBvblJlbmRlcjogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgcHJpdmF0ZSBsYXN0QW5pbWF0aW9uSWQgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgc2VydmljZTogUm91bmRQcm9ncmVzc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBlYXNpbmc6IFJvdW5kUHJvZ3Jlc3NFYXNlLFxuICAgIEBJbmplY3QoUk9VTkRfUFJPR1JFU1NfREVGQVVMVFMpIHByaXZhdGUgZGVmYXVsdHM6IFJvdW5kUHJvZ3Jlc3NEZWZhdWx0cyxcbiAgICBwcml2YXRlIG5nWm9uZTogTmdab25lXG4gICkge31cblxuICAvKiogQW5pbWF0ZXMgYSBjaGFuZ2UgaW4gdGhlIGN1cnJlbnQgdmFsdWUuICovXG4gIHByaXZhdGUgX2FuaW1hdGVDaGFuZ2UoZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiBmcm9tICE9PSAnbnVtYmVyJykge1xuICAgICAgZnJvbSA9IDA7XG4gICAgfVxuXG4gICAgdG8gPSB0aGlzLl9jbGFtcCh0byk7XG4gICAgZnJvbSA9IHRoaXMuX2NsYW1wKGZyb20pO1xuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlSW5WYWx1ZSA9IHRvIC0gZnJvbTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHNlbGYuZHVyYXRpb247XG5cbiAgICAvLyBBdm9pZCBmaXJpbmcgY2hhbmdlIGRldGVjdGlvbiBmb3IgZWFjaCBvZiB0aGUgYW5pbWF0aW9uIGZyYW1lcy5cbiAgICBzZWxmLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gc2VsZi5zZXJ2aWNlLmdldFRpbWVzdGFtcCgpO1xuICAgICAgICBjb25zdCBpZCA9ICsrc2VsZi5sYXN0QW5pbWF0aW9uSWQ7XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGFuaW1hdGlvbigpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IE1hdGgubWluKHNlbGYuc2VydmljZS5nZXRUaW1lc3RhbXAoKSAtIHN0YXJ0VGltZSwgZHVyYXRpb24pO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gc2VsZi5lYXNpbmdbc2VsZi5hbmltYXRpb25dKGN1cnJlbnRUaW1lLCBmcm9tLCBjaGFuZ2VJblZhbHVlLCBkdXJhdGlvbik7XG5cbiAgICAgICAgICBzZWxmLl91cGRhdGVQYXRoKHZhbHVlKTtcblxuICAgICAgICAgIGlmIChzZWxmLm9uUmVuZGVyLm9ic2VydmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzZWxmLm9uUmVuZGVyLmVtaXQodmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpZCA9PT0gc2VsZi5sYXN0QW5pbWF0aW9uSWQgJiYgY3VycmVudFRpbWUgPCBkdXJhdGlvbikge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkRlbGF5ID4gMCkge1xuICAgICAgICBzZXRUaW1lb3V0KHN0YXJ0LCB0aGlzLmFuaW1hdGlvbkRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKiogVXBkYXRlcyB0aGUgcGF0aCBhcHBlcmFuY2UuICovXG4gIHByaXZhdGUgX3VwZGF0ZVBhdGgodmFsdWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgIGNvbnN0IGFyYyA9IHRoaXMuc2VydmljZS5nZXRBcmModmFsdWUsIHRoaXMubWF4LCB0aGlzLnJhZGl1cyAtIHRoaXMuc3Ryb2tlIC8gMiwgdGhpcy5yYWRpdXMsIHRoaXMuc2VtaWNpcmNsZSk7XG4gICAgICBjb25zdCBwYXRoID0gdGhpcy5wYXRoLm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgcm91bmRlZCBsaW5lIGNhcCB3aGVuIHRoZSB2YWx1ZSBpcyB6ZXJvLCBiZWNhdXNlIFNWRyB3b24ndCBhbGxvdyBpdCB0byBkaXNhcHBlYXIgY29tcGxldGVseS5cbiAgICAgIGNvbnN0IGxpbmVjYXAgPSB0aGlzLnJvdW5kZWQgJiYgdmFsdWUgPiAwID8gJ3JvdW5kJyA6ICcnO1xuXG4gICAgICAvLyBUaGlzIGlzIGNhbGxlZCBvbiBlYWNoIGFuaW1hdGlvbiBmcmFtZSBzbyBhdm9pZCB1cGRhdGluZyB0aGUgbGluZSBjYXAgdW5sZXNzIGl0IGhhcyBjaGFuZ2VkLlxuICAgICAgaWYgKGxpbmVjYXAgIT09IHRoaXMuY3VycmVudExpbmVjYXApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZWNhcCA9IGxpbmVjYXA7XG4gICAgICAgIHBhdGguc3R5bGUuc3Ryb2tlTGluZWNhcCA9IGxpbmVjYXA7XG4gICAgICB9XG5cbiAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdkJywgYXJjKTtcbiAgICB9XG4gIH1cblxuICAvKiogQ2xhbXBzIGEgdmFsdWUgYmV0d2VlbiB0aGUgbWF4aW11bSBhbmQgMC4gKi9cbiAgcHJpdmF0ZSBfY2xhbXAodmFsdWU6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKHZhbHVlIHx8IDAsIHRoaXMubWF4KSk7XG4gIH1cblxuICAvKiogRGV0ZXJtaW5lcyB0aGUgU1ZHIHRyYW5zZm9ybXMgZm9yIHRoZSA8cGF0aD4gbm9kZS4gKi9cbiAgZ2V0UGF0aFRyYW5zZm9ybSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGRpYW1ldGVyID0gdGhpcy5fZ2V0RGlhbWV0ZXIoKTtcblxuICAgIGlmICh0aGlzLnNlbWljaXJjbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb2Nrd2lzZVxuICAgICAgICA/IGB0cmFuc2xhdGUoMCwgJHtkaWFtZXRlcn0pIHJvdGF0ZSgtOTApYFxuICAgICAgICA6IGB0cmFuc2xhdGUoJHtkaWFtZXRlciArICcsJyArIGRpYW1ldGVyfSkgcm90YXRlKDkwKSBzY2FsZSgtMSwgMSlgO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuY2xvY2t3aXNlKSB7XG4gICAgICByZXR1cm4gYHNjYWxlKC0xLCAxKSB0cmFuc2xhdGUoLSR7ZGlhbWV0ZXJ9IDApYDtcbiAgICB9XG4gIH1cblxuICAvKiogUmVzb2x2ZXMgYSBjb2xvciB0aHJvdWdoIHRoZSBzZXJ2aWNlLiAqL1xuICByZXNvbHZlQ29sb3IoY29sb3I6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmljZS5yZXNvbHZlQ29sb3IoY29sb3IpO1xuICB9XG5cbiAgLyoqIENoYW5nZSBkZXRlY3Rpb24gY2FsbGJhY2suICovXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoY2hhbmdlcy5jdXJyZW50KSB7XG4gICAgICB0aGlzLl9hbmltYXRlQ2hhbmdlKGNoYW5nZXMuY3VycmVudC5wcmV2aW91c1ZhbHVlLCBjaGFuZ2VzLmN1cnJlbnQuY3VycmVudFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlUGF0aCh0aGlzLmN1cnJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBEaWFtZXRlciBvZiB0aGUgY2lyY2xlLiAqL1xuICBfZ2V0RGlhbWV0ZXIoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5yYWRpdXMgKiAyO1xuICB9XG5cbiAgLyoqIFRoZSBDU1MgaGVpZ2h0IG9mIHRoZSB3cmFwcGVyIGVsZW1lbnQuICovXG4gIF9nZXRFbGVtZW50SGVpZ2h0KCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLnJlc3BvbnNpdmUpIHtcbiAgICAgIHJldHVybiAodGhpcy5zZW1pY2lyY2xlID8gdGhpcy5yYWRpdXMgOiB0aGlzLl9nZXREaWFtZXRlcigpKSArICdweCc7XG4gICAgfVxuICB9XG5cbiAgLyoqIFZpZXdib3ggZm9yIHRoZSBTVkcgZWxlbWVudC4gKi9cbiAgX2dldFZpZXdCb3goKTogc3RyaW5nIHtcbiAgICBjb25zdCBkaWFtZXRlciA9IHRoaXMuX2dldERpYW1ldGVyKCk7XG4gICAgcmV0dXJuIGAwIDAgJHtkaWFtZXRlcn0gJHt0aGlzLnNlbWljaXJjbGUgPyB0aGlzLnJhZGl1cyA6IGRpYW1ldGVyfWA7XG4gIH1cblxuICAvKiogQm90dG9tIHBhZGRpbmcgZm9yIHRoZSB3cmFwcGVyIGVsZW1lbnQuICovXG4gIF9nZXRQYWRkaW5nQm90dG9tKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMucmVzcG9uc2l2ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VtaWNpcmNsZSA/ICc1MCUnIDogJzEwMCUnO1xuICAgIH1cbiAgfVxufVxuIl19